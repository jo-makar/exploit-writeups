# tcp-echo-server

Simple TCP echo server with buffer overflow vulnerability (original source [here](https://github.com/polyverse/tcp-echo-server))

A minor change was made to the original to make the code easier to work with:

```sh
$ diff main.c.orig main.c
38a39,44
>       int enable = 1;
>       if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &enable, sizeof(enable)) < 0) {
>               fprintf(stderr, "Error on setsockopt(). Exiting...\n");
>               exit(EXIT_FAILURE);
>       }
> 
```

## tcp-echo-server-1

For the first exploit iteration, disable stack smashing protection (-fnostack-protector) and allow instruction execution on the stack (-zexecstack).

Build the Docker container image with: `cd tcp-echo-server-1; docker build -t tcp-echo-server:latest .`

(Remove old images by adding `&& docker images -f dangling=true -q | xargs -r docker rmi`)

Launch an interactive shell within the container with: `docker run -it --rm -p 8080:8080 --entrypoint /bin/bash tcp-echo-server:latest`

The read() in the vuln_read() is vulnerable to a buffer overflow; can read as many as 1000 bytes into an 80 byte stack-backed buffer.

```c
#define BUFFER_SIZE 1000

void vuln_read(int client_fd)
{
        char buffer[80] = {0};  // initialize array with zeroes

        int n = read(client_fd, buffer, BUFFER_SIZE);
        printf("read: %d bytes\n", n);
  
        // echo input back to client
        write(client_fd, buffer, n + 1); // include null
}
```

Since stack smashing protection is disabled and stack instruction execution is allowed, the simpliest exploit is to arrange for buffer to contain shellcode and to overwrite the vuln_read() return address on the stack to return to that shellcode.

Gather some runtime info by launching the application with gdb:

```sh
[root@<containerid> polyverse]# gdb tcp-echo-server
<startup messages elided>
gdb-peda$ break vuln_read
Breakpoint 1 at 0xa50: file main.c, line 13.
gdb-peda$ run
Starting program: /opt/polyverse/tcp-echo-server
```

Connect to the server (say with netcat) and send some text to trigger the breakpoint.

```sh
<registers, code, stack dump elided>
Breakpoint 1, vuln_read (client_fd=0x8) at main.c:13
13              char buffer[80] = {0};  // initialize array with zeroes
Missing separate debuginfos, use: debuginfo-install glibc-2.17-292.el7.x86_64
gdb-peda$ print &buffer
$0 = (char (*)[80]) 0x7fff5dc15ce0
gdb-peda$ print &n
$1 = (int *) 0x7fff5dc15d3c
gdb-peda$ print $rbp
$2 = (void *) 0x7fff5dc15d40
gdb-peda$ x/1xg $rbp
0x7fff5dc15d40: 0x00007fff5dc15db0
gdb-peda$ x/1xg $rbp+8
0x7fff5dc15d48: 0x0000558fbe231c5c
gdb-peda$ list *(*(long int *)($rbp+8)) # or just list *0x0000558fbe231c5c
0x558fbe231c5c is in main (main.c:66).
61                      if (client_fd < 0)
62                      fprintf(stderr, "Error on accept().\n");
63
64                      vuln_read(client_fd);
65
66                      close(client_fd);
67              }
68
69              close(server_fd);
70
```

With this the layout of the stack can be made:

![stack](stack.png)

